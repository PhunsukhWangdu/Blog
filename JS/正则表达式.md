## 正则表达式

#### 创建正则表达式

如果正则已知，采用正则表达式字面量：

	var pattern = /test/
	
需要在运行时动态构建字符串，采用构造RegExp对象实例

	var pattern = new RegExp('test')
	
在字面量语法中，反斜杠\不需要转义，而在字符串中，反斜杠需要前面加一个反斜杠来转义\\。

#### 标志

i: 不区分大小写
g:匹配模式中的所有实例
m:允许匹配多个行，如textarea中的值

用法：
	
	/test/ig    
	new RegExp('test', 'ig')
	
#### 匹配一类字符

匹配字符集中的某一个字符
	
	[abc] 匹配a,b,c中的一个 就一个

匹配字符集以外的字符

	[^abc] 除了a,b,c以外的字符
	
匹配一个范围的某一个字符

	[a-m]  //字典顺序
	[abcdefghigklm]
	
#### 匹配开始与结束

^匹配开始 

$匹配结尾

#### 匹配连续重复

	/aaaaa/ 连续的5个a

* ? 标识前面的字符是可选的，出现一次或者根本不出现
* + 出现一次或者多次
* * 出现0次或者多次
* {n} 标识前面的字符连续的次数n
* {n, m} 字符出现的次数区间 连续n个到m个
* {n, }开区间，大于等于n个连续的字符

#### 常用预定义字符

* \f 换页符
* \r 回车
* \n 换行
* . 匹配除了新行(\n)之外的任意字符
* \d 匹配任意数字[0-9]
* \D 匹配任意非数字[^0-9]
* \w 匹配包括下划线的任意单词字符 [a-zA-z0-9]
* \W 匹配任意非单词字符
* \s 任意空白字符 空格，制表符，换页符等等
* \S 非空白字符
* \b 单词边界
* \B 非单词边界

匹配包括换行符的所有字符的几种方式：

* /[\S\s]*/	（空白字符和非空白字符的合集，就是所有字符）
* /(?:.|\s)*/  （\s包括换行，.不包含，取合集）

#### 或 |

	/a|b/ 匹配a或b
	/(ab)+|(cd)+/ 出现一次或多次的ab 或 cd
	
#### 反向引用

\n n是要引用的捕获数标，从1开始，如\1,\2

**捕获组及其编号：**

    1) 捕获组就是匹配到的内容，按照()子表达式划分成若干组；

    2) 例如正则表达式：(ab)(cd(ef))就有三个捕获组，每出现一对()就是一个捕获组

    3) 引擎会对捕获组进行编号，编号规则是左括号(从左到右出现的顺序，从1开始编号；


例如： /^([abc])d\1/ 表示以a或b或c开头的接着一个d的字符，\1表示和第一个捕获相同的字符串，但是并不是a,b,c中的任意一个，而是准确的前面匹配到[abc]的字符的那个字符，所以是要在执行时才能确定的。

例如：要匹配一个开始和关闭标签

	/^<(\w+)>(.+)<\/\1>/

^< 表示以<开头
(\w+)任意单词字符串一次货多次，就是标签名
(.+) dom标签中间的内容 任意除了换行的字符 出现一次或多次
<\/  匹配"</" /需要转义
\1 取匹配到捕获组下表为1的(\w+)字符串，在运行时得到的匹配了第一个捕获组的字符串 
> dom标签的结尾

**捕获的引用**

除了\n，$同样可以获取我们捕获的引用,$后面跟着捕获分组的下标

	"fontFamily".replace(/([A-Z])/g, "-$1").toLowerCase() === "font-family"

**阻止不必要的捕获**

如果我们不想捕获某个分组，可以在括号开始后加一个？：，一个被动子表达式

	/((?:aaa-)+)bbb/

这样我们只会捕获到bbb前面的那个分组


#### 编译正则表达式

编译发生在正则表达式第一次被创建的时候，而执行发生在我们使用编译过的争取去匹配字符串的时候。

编译期间，表达式通过js引擎进行解析，转换成其内部表示，解析和转换的过程在每次正则被创建的时候都会发生，浏览器会做一些内部优化工作

通常浏览器可以很智能的判断相同的正则在何时被调用，并缓存该特定表达式编译的结果，但是我们还是要在代码中对复杂的正则进行预定义，来提高性能

构造器new RegExp创建正则，允许我们运行时通过动态创建的字符串构建和编译一个正则，允许我们在运行时编译正则表达式。

每个正则表达式都有一个独立的对象表示，每次创建一个正则表达式，都会为此创建一个新的正则表达式对象，结果永远是独一无二的。

对正则表达式预编译预构建以便多次利用，对性能有很大的提升。

## test, exec, match, replace
pattern 为RegExp的实例, str 为String的实例

* pattern.test(str)	判断str是否包含匹配结果	包含返回true，不包含返回false。
* pattern.exec(str)	根据pattern对str进行正则匹配,返回匹配结果数组,如匹配不到返回null
* str.match(pattern)	根据pattern对str进行正则匹配,返回匹配结果数组,如匹配不到返回null
* str.replace(pattern, replacement)	根据pattern进行正则匹配,把匹配结果替换为replacement	一个新的字符串

#### RegExp test()

用于检测一个字符串是否匹配某个模式：

	RegExpObject.test(string)
	
如果字符串 string 中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false：

	/\d/.test('asdf2') // --true   检测字符串`'asdf2'`中是否函数数字

#### RegExp exec()

在全局正则时恢复捕获功能，可以对一个表达式多次调用，每次调用返回下一个匹配的结果。

	RegExpObject.exec(string)
	while(match = reg.exec(str) !== null)

如果在string中找到了匹配的文本，则返回一个**包含这些文本的数组**，否侧返回null

* 返回的数组的第一个元素是与整个正则匹配的文本
* 然后数组的第二个元素是与整个正则的第一个捕获相匹配的文本
* 数组的第三个元素整个正则的第二个捕获相匹配的文本，以此类推。


```
var result = /(\d+)-(\w+)/.exec('12-ab');
console.log(result) 
// --> ["12-ab", "12", "ab", index: 0,input: "12-ab"] 
```
	
	
exec() 都会把完整的细节添加到它返回的数组中，这里的细节指的就是index和input

* index: 匹配文本的第一个字符的位置
* input: 输入的整体的文本了

```
console.log(result.index) // --> 0
console.log(result.input) // --> '12-ab'
```

exec方法只对指定的字符串进行一次匹配，可循环调用，正则是全局的，则顺序返回匹配的，若正则不是全局的，则调用几次都返回第一组匹配的

* 同一正则表达式，在全局匹配模式下，每次实例的lastIndex属性的值为匹配文本最后一个字符的下一个位置，上面例子中第一次匹配的时候最后一个字符位置为1，则下一个位置为：2
* 当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0

#### String match()

利用String的match方法

* 应用于局部正则表达式时，返回一个数组，包括匹配成功的整个字符串以及捕获的结果
* 应用于全局正则表达式时(/g)，返回的不再是第一个匹配的结果和捕获的分组，而是获得所有匹配的结果，每个匹配的捕获结果不再返回。


**局部正则表达式,非全局匹配**

```
var a = 'aaaa'.match(/\w/);
console.log(a); // ["a", index: 0, input: "aaaa"]
```
可以看到，和exec()一样，在数组中返回了index 和 input属性。

**全局匹配,全局正则表达式**
```
var a = 'aaaa'.match(/\w/g);
console.log(a); // ["a", "a", "a", "a"]
```

全局匹配就和exec方法有很大的不同了，他直接返回了所有符合匹配的子字符串的数组，另外，index和input属性也不在其中了

#### String replace()

	"fontFamily".replace(/([A-Z])/g, "-$1").toLowerCase() === "font-family"

像上面举过的例子，第一个参数是正则时，允许我们替换匹配的元素

* 当未找到匹配项的时候，返回原始字符串。

   		 'aaaa'.replace('bbb', 'b')     //"aaaa"
   
* 当pattern为字符串或者为非全局的RegExp对象的时候，只替换找到的第一项匹配项。

	    'aaaa'.replace('a', 'b')     //"baaa"
	    'aaaa'.replace(/\w/, 'b')    //"baaa"

* 当pattern为全局的RegExp对象的时候，替换每一项匹配项。

   		'aaaa'.replace(/\w/g, 'b')    //"bbbb"
    

第二个参数不仅可以接受固定的字符串，还可以接受一个函数作为替换值，传入函数时，每次匹配成功都会调用该函数，并接受入参如下：

* 匹配的完整文本
* 匹配的捕获，一个捕获对应一个参数
* 匹配字符串在源字符串中的索引
* 源字符串


		 function upper(all,letter,idx,ori) {
			  console.log(all,letter,idx,ori);
			  return ''
			}
		"aaa-bbb-ccc".replace(/-(\w)/g, upper)
输出：
		-b b 3 aaa-bbb-ccc
		-c c 7 aaa-bbb-ccc
		"aaabbcc"

**特殊的 $:**

replacement 中的 $ 字符具有特定的含义。从模式匹配得到的字符串将用于替换。

| 字符 | 替换文本 |
| ------ | ------ |
| 1、2、...、$99 | 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本 |
| $& | 与 regexp 相匹配的所有子串 |
| $` | 位于匹配子串左侧的文本 |
| $' | 位于匹配子串右侧的文本 |
| $$ | 直接量符号 |

```
	//第一种情况：
	'aa11AA'.replace(/([a-z]+)(\d+)([A-Z]+)/g, '$1'); // "aa"
	'aa11AA'.replace(/([a-z]+)(\d+)([A-Z]+)/g, '$2'); // "11"
	'aa11AA'.replace(/([a-z]+)(\d+)([A-Z]+)/g, '$3'); // "AA"
	
    //猜想 如果是 $4 回事什么呢？ undefined ? 
    'aa11AA'.replace(/([a-z]+)(\d+)([A-Z]+)/g, '$4'); // "$4"
    //所以，要是没有该子项，则当成普通字符串处理了
	    
	//第二种情况：
	'aa11AA'.replace(/([a-z]+)(\d+)([A-Z]+)/g, '$&'); //"aa11AA"
	
	//第三种情况：
	'aa11AA'.replace(/(\d+)/g, '$`'); //"aaaaAA"
	
	//第四种情况：
	'aa11AA'.replace(/(\d+)/g, "$'"); //"aaAAAA"
	
	//第五种情况：
	'aa11AA'.replace(/(\d+)/g, '$$'); //"aa$AA"
```

一些常见使用：

	str.replace(/^\s+|\s+$/g, "") //替换首尾空格

