#Git

历史：Linus的作者创建了开源的Linux，02年以前代码管理都依赖手动合并，后来管理不了了，拒绝SVN和CVS这些中央式版本控制的工具(原因如下表格)，采用免费授权给Linux社区的BitKeeper工具，再后来05年社区的大牛要破解BitKeeper被人家公司发现要收回BitKeeper对Linux的免费的使用权，Linus一口气两周内用C写了一个分布式的版本控制系统——Git。接着08年GitHub问世，利用Git为无数开源项目提供代码的托管存储

分布式版本控制系统：Git,BitKeeper

集中式版本控制系统：CVS,SVN

差别：

|    |      集中式（SVN）      |  分布式（Git） |
|----------|:-------------:|------:|
|代码保存|项目要开发完推送给中央服务器。|开发人员在本地仓库存储提交代码修改的历史|
| 网络 |必须要联网才能工作，文件过大或者网速不好会很慢甚至失败。|没有网络的情况下也可以在本地仓库执行commit、查看版本提交记录、以及分支操作，在有网络的情况下执行 push到Remote Repository远端仓库。
|文件存储格式|按照原始文件存储，体积较大|按照元数据方式存储，体积很小|
|版本号|有|无|
|分支操作的影响|创建新的分支则所有的人都会拥有和你一样的分支，本质上是因为都在中央仓库上操作|分支操作不会影响其他开发人员|
|提交|提交的文件会直接记录到中央版本库|提交是本地操作，需要执行push操作才会到远端仓库|


*特别注意，分布式版本控制系统的远端仓库，有时候也被叫“中央服务器”，不同于集中式的中央服务器，分布式中它可以理解成一个中转站，用来协作同步各个本地仓库的代码，实际上任何一个服务器都可以取代它的作用，只是为了方便大家“交换”代码*


##clone远程仓库、创建本地仓库
![](https://i.imgur.com/Zuiwd3o.png)

	git clone https://github.com/****.git 

clone项目到本地之后，我们可以看到目录下有一个叫.git的隐藏文件
![](https://i.imgur.com/L3aCJHm.png)

这个.git文件夹就是我们的本地仓库（Local Repository）.git文件夹所在的根目录就是我们的工作目录（Working Directory）

clone下来的项目我们就可以正常开发了，当然我们也可以在本地直接创建一个本地仓库，之后再与远程创建的仓库进行关联，先执行

	git init
命令执行的目录下就有了一个.git文件夹，我们在创建了一个本地仓库，接着与远程仓库进行关联：

	git remote add origin https://github.com/****.git 

##工作目录 暂存区 版本库 远程仓库

全文会频繁提到的几个关键词，可以先跳过，看到的时候回来看可能理解的更好~

**工作目录（working directory）**就是我们创建的项目文件夹，我们开发项目的地方，.git所在根目录

	新创建的文件要添加到暂存区——git add

**暂存区（index/staging area）**是指储存了所有待提交的改动的地方，只有在暂存区存在的文件，本地仓库才会追踪到它的变化。

*暂存区对应在.git文件夹中的index中，是一个二进制文件，可以理解为一个索引，内容包括根据文件名，文件模式和元数据进行排序的文件路径列表，每个路径都有权限以及Blob类型的SHA-1标识符（就是我们平时提交记录对应的那一串编码，下面会讲到）*

	把文件从暂存区提交到本地的版本库中——git commit

**版本库/本地仓库**（Repository）可以理解为就是我们分布式版本控制中提到的我们本地的代码版本库，这里面有我们所有提交版本版本的数据。

*对应.git中的HEAD,实质上是一个指针，指向最新放入仓库的版本，默认情况下git为我们自动生了一个分支master，head就指向这个分支*

**远程仓库**（Remote）托管代码的服务器，上面介绍分布式版本控制中的远程中央仓库，可以理解为一台专门用于协作开发时数据交换的电脑。

贴一张大牛的图：

![](https://i.imgur.com/zvqcgU2.png)

![](https://i.imgur.com/aQJUczH.png)

	git diff 比较的是工作区和暂存区的差别
	git diff HEAD 可以查看工作区和版本库的差别
	git diff --cached 比较的是暂存区和版本库的差别

##一个简单的流程
#### 涉及到的命令：git status/ git add/ git commit/ git log/ git pull /git push ####

创建一个文件夹，添加新的文件

	git status //查看工作目录和暂存区的状态

![](https://i.imgur.com/svSfUqC.png)

untracked files表示未追踪的文件，就是新创建的src文件夹，未追踪的意思就是当前本地git仓库对它没有任何的记录，对本地仓库来说是不存在的，在我们提交代码的时候也不会提交上去

	git add 文件 //将新创建的文件添加到暂存区

执行之后没有任何提示，执行git status看下当前本地仓库的状态：

![](https://i.imgur.com/mqpxIDh.png)

新添加的文件进入暂存区，从untracked未跟踪状态变为stage已暂存状态。接着文件进入暂存区之后，我们的修改就都可以被暂存区追踪到，我们修改一下新增加文件夹下面的test.js文件

![](https://i.imgur.com/iDWdbGg.png)

这次文件左边的状态从New file（新建）变成了modified（修改），上面的提示不再是untracked（不在追踪范围）而是not staged for commit（还不在待提交的暂存区中）。意思就是，本地仓库现在已经认识了这个文件，它被修改了，还没到储存待提交信息的暂存区中，还是使用add添加到暂存区：

	git add 文件名

查看下工作目录和暂存区当前文件的状态

![](https://i.imgur.com/bcxUsf5.png)

按照提示，接着就可以commit提交了：

	git commit //将暂存区文件提交到本地版本库中

输入git commit回车之后，会进入命令模式，输入小写的i可以切换到插入模式，然后输入这次提交的备注信息，然后不要回车，按ESC返回命令模式，输入ZZ保存，一次提交就完成了。

	git log //查看提交历史

![](https://i.imgur.com/p4wItGH.png)
	
	git push //将本地仓库推送到远程仓库

![](https://i.imgur.com/ICbt9CL.png)

直接使用push会有这样的提示。意思是当前分支没有和上游远程分支做关联，git不知道你要推送到远程仓库的哪个分支上，我们想要和远程的master分支关联，按照提示输入：

![](https://i.imgur.com/hQanMfS.png)

origin是远程仓库的代指，master是远程仓库上的分支名，这里的origin/master，即远程仓库的master分支，就是我们实验项目的远程仓库。我们把关联的远程分支设置成了origin/master，之后直接执行git push默认就会推到远程的master下，当然我们不省略传入远程的分支名就会推送到对应的分支上。

特别注意，如果你使用的不是clone而是直接本地init一个仓库与远程仓库关联的方式，第一次推送可能会遇到这个情况：

![](https://i.imgur.com/HRg2Ciz.png)

这是因为在远程仓库上创建新的项目时勾选了自动生成readme/.gitignore，它们就作为远程仓库的第一次commit，而我们本地git init的仓库没有远程仓库的readme/.gitignore文件，所以无法提交成功。所以要先拉取一下远端的代码同步到本地，再把我们的改动提交上去。先pull再push。当然如果你创建远程仓库时不勾选readme/.gitignore就可以直接push上去

但是光执行pull也是不够的，远程仓库有一个提交，我们本地仓库也有一个提交，直接拉取远端的代码，这两个提交谁先谁后呢？没有操作相同文件时可能无所谓，但是一旦都修改了同一个文件，就涉及到哪次提交在后，覆盖的问题，所以要执行：

	git pull --rebase origin master

这条指令的意思是把远程库中的更新合并到本地库中，–rebase的作用是取消掉本地库中刚刚的commit，并把他们接到更新后的版本库之中，rebase具体下面会讲到，先看下结果

![](https://i.imgur.com/BXdpIpm.png)

接着push代码到远端仓库（orgin)的master就成功了

![](https://i.imgur.com/mKBAmO7.png)

看下提交记录

![](https://i.imgur.com/q7JdSK7.png)

远程仓库的initial commit是第一条记录，我们刚提交的在后面


##commit信息历史
#### 涉及到的命令：git log####
![](https://i.imgur.com/ORGPyna.png)

每一个commit对应一个唯一id，是40为的数字和字符组成的字符串，是属于每一个commit的一个id，一个SHA-1校验和

![](https://i.imgur.com/M86R3KZ.png)

![](https://i.imgur.com/poghrAD.png)

![](https://i.imgur.com/9OOPNjd.png)

##丢弃之前的提交reset --hard

最新一次的commit的内容有问题，想要丢弃这次提交，先log看下提交记录：

![](./images/wrongcommit-log.png)

如果想要恢复到最新一次前面的那次commit记录，也就是the third，执行：

	git reset --hard HEAD^

head指向最新的一个commit，也就是途中的wrong commit,^标识从当前位置向前数，有几个就是向前数几个，所以上面的命令的意思就是恢复到head对应的的commit前面的commit，也就是the third。

执行结果：

![](./images/resethardhead1.png)

这时我们git log看下commit的记录：

![](./images/1afterresethard.png)

同理如果要恢复到head前面的第二个commit，也就是the second,在head后两个^:

	git reset --hard HEAD^^
	
被撤销的那条提交并没有消失，只是log不再展现出来，因为已经被丢弃。如果你在撤销它之前记下了它的 SHA-1 码，那么还可以通过这个编码找到它，执行如下：

![](./images/1.png)

再log看下commit记录，wrongcommit已经重新出现在记录里，并且head指向它：

![](./images/2.png)

	git reset --hard 目标commit


参考文章：
https://www.jianshu.com/p/4f8b56d0fd5b