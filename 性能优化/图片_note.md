图片优化

js和css是对用户不可见的，或许会影响图片的展示，但是对用户来说最直观最快的体验是图片和文字的展示，所以性能优化的中心都放在如何更快的下载js和css是不完整的，图片更快更好的展现也是性能优化的重中之重

压缩图片的体积，牺牲部分图片的质量，要在质量和效率之间找到一个平衡点

HTTP-Archive 这个网站，定期抓取web网页的资源并统计

Web 图片格式有 JPEG/JPG、PNG、WebP、Base64、SVG 等

图片的像素是由二进制来表示的，像素对应的二进制位数越多，能表示的颜色越多，图像质量就越高，也越大

jpeg/jpg
一个东西 jpg是jpeg的一个扩展名
有损压缩，体积小，不支持透明
2的24次方，支持1600多万种颜色，压缩至体积的50%一下的时候也可以保存60%的质量，高质量的压缩方式

JPG 的缺陷
有损压缩在上文所展示的轮播图上确实很难露出马脚，但当它处理矢量图形和 Logo 等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。
my:支持颜色更多，只不过是细节处理不好

png-8/png-24
256种颜色，1600万颜色，无损压缩，支持透明图片的设置
应用：考虑到 PNG 在处理线条和颜色对比度方面的优势，我们主要用它来呈现小的 Logo、颜色简单且对比强烈的图片或背景等，透明图片

svg
文件体积更小，可压缩性更强，不失真，兼容性好
基于xml语法的图像格式，可缩放矢量图形，对图像的处理不是基于像素，而是基于图像的形状
文本文件，可放到dom中，也可以通过.svg来访问
无限放大而不失真

将 SVG 写入 HTML：

	<!DOCTYPE html>
	<html lang="en">
	<head>
	    <meta charset="UTF-8">
	    <title></title>
	</head>
	<body>
	    <svg xmlns="http://www.w3.org/2000/svg"   width="200" height="200">
	        <circle cx="50" cy="50" r="50" />
	    </svg>
	</body>
	</html>
将 SVG 写入独立文件后引入 HTML:

	<img src="文件名.svg" alt="">...

bae64
文本文件，依赖编码，小图标解决方案
不是一种图片格式 而是一种编码方式
基于8bit的图像编码方式，可以直接放入html/css中，减少服务器请求
大图不用base64是因为，编码过后的图片大小基本为原来的4/3，编码小图标的时候，浏览器解析的时间以及带来的文件膨胀，相比http请求来说，可以忽略不计，而在编码大图片时，文件体积的大小和浏览器解析的时间相比一个http请求来说，减少一个请求是无法替代这个庞大的体积带来的性能开销的

小于2k时候考虑用，是雪碧图的一个替代，优先还是用雪碧图，维护成本很高，要改代码

工具推荐：
这里最推荐的是利用 webpack 来进行 Base64 的编码——webpack 的 url-loader 非常聪明，它除了具备基本的 Base64 转码能力，还可以结合文件大小，帮我们判断图片是否有必要进行 Base64 编码。

webp
2010谷歌提出，旨在加快图片加载速度的图片格式，支持有损压缩和无损压缩

WebP 的官方介绍对这一点有着更权威的阐述：

与 PNG 相比，WebP 无损图像的尺寸缩小了 26％。在等效的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小 25-34％。 无损 WebP 支持透明度（也称为 alpha 通道），仅需 22％ 的额外字节。对于有损 RGB 压对于有损 RGB 压缩可接受的情况，有损 WebP 也支持透明度，与 PNG 相比，通常提供 3 倍的文件大小。

兼容性不好，编码麻烦

淘宝的方式：

	<img src="//img.alicdn.com/tps/i4/TB1CKSgIpXXXXccXXXX07tlTXXX-200-200.png_60x60.jpg_.webp" alt="手机app - 聚划算" class="app-icon">
正在不兼容的浏览器中

	<img src="//img.alicdn.com/tps/i4/TB1CKSgIpXXXXccXXXX07tlTXXX-200-200.png_60x60.jpg" alt="手机app - 聚划算" class="app-icon">

基本方式就是先做兼容性判断，通过字符串的切割，引入png或者webp

服务器根据 HTTP 请求头部的 Accept 字段来决定返回什么格式的图片。当 Accept 字段包含 image/webp 时，就返回 WebP 格式的图片，否则返回原图。这种做法的好处是，当浏览器对 WebP 格式图片的兼容支持发生改变时，我们也不用再去更新自己的兼容判定代码，只需要服务端像往常一样对 Accept 字段进行检查即可。